from Domain.State import State
import numpy as np
from copy import deepcopy

class HillClimbingAlgorithm(object):
    def __init__(self,n,nrOfTrials):
        self.n = n  # dimensions for the matrix
        self.state = self.getInitialIndivid()
        self.numberofTrials=nrOfTrials# a state (a square)
        #print("first"+str(self.state))
        self.mutationFactor = (n * (n - 1)) * 2  # a number big enough for the fitness func as to not return neg nbs

    def getInitialIndivid(self):
        #gets an individ aka a matrix (everytime a different one)
        state = []
        for i in range(2*self.n): #we will have 2*n permutations
            permutation = np.random.permutation(self.n)
            for j in range(len(permutation)):
                #we just add 1 to be like in the example
                permutation[j]+=1
            permutation=tuple(permutation)
            state.append(permutation)
        individ=State(state)
        return individ

    def fitnessFunction(self,state):
        #ret a number: the bigger, the closer you are to the solution
        #aka it checks the permutations in the state and gives a result based on how close to the sol is this state
        state_vals=state.get_vals()
        version1=0 #it would be perfect to remain 0 for it to be a sol

        #we check the lines first
        for i in range(self.n):
            l=[]
            for j in range(self.n):
                l.append(state_vals[i][j]) #put the permutations from lines in l
            #get how many perms are the same: if 0 => all unique => very close to sol
            version1+=len(l)-len(set(l)) #set holds only unique perm from l

        #we check the columns second
        version2=0
        for i in range(self.n):
            l=[]
            for j in range(self.n,self.n*2):
                l.append(state_vals[j][i]) #perms from columns in l
            version2+=len(l)-len(set(l))

        #lastly we check that all pairs of permutations are different from one another no matter the position
        version3=0
        l=[]
        for i in range(self.n):
            j=self.n+i #this is how we get the second part of the pair (i,j) from state
            for k in range(self.n):
                l.append((state_vals[i][k],state_vals[j][k])) #here we add pairs of permutations from the state
        version3+=len(l)-len(set(l))

        #now return a number
        return self.mutationFactor-version3-version2-version1


    def keyGeneratorForSorting(self,state):
        #gets a state and returns the fitness of it (we will use these for the sorting criteria when making a new population)
        return self.fitnessFunction(state)

    def findBestNeighbour(self):
        #returns the best neighbour given by only changing one permutation in the state or the ret the current state
        neighs=[] #list of neighbours for state in self
        for i in range(self.n*2):
            neigh=deepcopy(self.state) #this will be generated by only changing a perm
            neigh_vals=neigh.get_vals()
            neigh_vals[i]=np.random.permutation(self.n) #we change the perm
            for j in range(self.n):
                neigh_vals[i][j]+=1 #to be like in example
            neigh_vals[i]=tuple(neigh_vals[i])
            neigh.set_vals(neigh_vals)
            neighs.append(neigh)

        #sort the neighbours to get the best in front
        neighs.sort(key=self.keyGeneratorForSorting,reverse=True)

        #now checks if the best neigh is better than state itself, if so returns it
        if self.fitnessFunction(neighs[0])>self.fitnessFunction(self.state):
            return neighs[0]
        else:return self.state

    def greedyHillClimbing(self):
        #we use greedy (by choosing the best choice of next always) to get to a solution or not in a number of trials
        #we start from a square randomly generated and we always change it or not to get to the best solution
        l=[] #we put here identical states to know when to stop in case of no solution
        while len(l)<self.numberofTrials:
            if self.fitnessFunction(self.state)==self.mutationFactor:
                print("solution:\n"+str(self.state))
                return self.state
            self.state=self.findBestNeighbour()
            #print("len"+str(len(l))+"state:\n"+str(self.state))
            if self.state in l:
                l.append(self.state) #we put the state if it hasn't changed
            else:
                l=[self.state] #else we reset the list
        print("no sol")

